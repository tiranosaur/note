Aspect — модуль или класс, реализующий сквозную функциональность. 
Аспект изменяет поведение остального кода, применяя совет в точках соединения, 
определённых некоторым срезом.

Advice — средство оформления кода, которое должно быть вызвано из точки соединения. 
Совет может быть выполнен до, после или вместо точки соединения.

JoinPoint — точка в выполняемой программе, где следует применить совет.
Многие реализации АОП позволяют использовать вызовы методов и обращения к полям объекта в качестве точек соединения.

Pointcut — набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному совету. 
Самые удобные реализации АОП используют для определения срезов синтаксис основного языка 
(например, в AspectJ применяются Java-сигнатуры) и допускают их повторное использование с помощью переименования и комбинирования.

Introduction — изменение структуры класса и/или изменение иерархии наследования 
для добавления функциональности аспекта в инородный код. Обычно реализуется с 
помощью некоторого метаобъектного протокола (англ. metaobject protocol, MOP).



      -----------------------pointcuts------------------------
inside: определяет выполнение всех методов некоторого типа, а также может использоваться для указания пакета.

this: Spring Aop основан на динамическом прокси. Сгенерированный bean-компонент также является прокси-объектом. Это прокси-объект. Когда этот объект может быть преобразован в указанный тип, соответствующая точка входа - это, и Spring Aop вступит в силу.

target: когда прокси-объект может быть преобразован в указанный тип, соответствующая точка входа - это, и Spring Aop вступит в силу.

args: вступает в силу, когда параметром выполняемого метода является указанный тип.

@target: Действует, когда целевой объект прокси имеет указанную аннотацию.

@args: вступает в силу, когда указанная аннотация относится к типу параметра исполняемого метода.

@within: аналогично @target, посмотрите официальные документы и онлайн-высказывания о том, что @within требует, чтобы класс целевого объекта или родительский класс имели указанную аннотацию, тогда @within вступит в силу, а @target должен быть целевым объектом Класс имеет указанную аннотацию. В соответствии с авторским тестом, оба из них, пока есть определенные аннотации на целевой класс или родительский класс.

@annotation: вступает в силу, когда указанная аннотация находится в исполняемом методе.

bean: вступает в силу, когда вызываемый метод является методом указанного bean-компонента.
