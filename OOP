Интерфейс - такой же абстрактный класс,только в нем не может быть свойств и не определены тела у методов.

Так же стоит заметить, что абстрактный класс наследуется(etxends), 
а интерфейс реализуется (implements). Вот и возникает разница между ними, 
что наследовать мы можем только 1 класс, а реализовать сколько угодно.
------------------------------------------------------------------------
полиморфизм
  один интерфейс - много реализаций
инкапсуляция
  отделение интерфейса от реализации
  Способность объекта скрывать свою реализацию
наследование
  Наследование это процесс благодаря которому один объект может приобрести свойства другого объекта 
  (наследование всех свойств одного объекта другим) и добавлять черты характерны только для него самого!
  Наследование расширяет класс родитель. Наследование описывается словом «является». 
  Легковой автомобиль является автомобилем. Вполне естественно, если он будет его наследником.
  
  Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. 
  Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. 
  Выделяют два частных случая ассоциации: композицию и агрегацию.
  
    Композиция – это когда двигатель не существует отдельно от автомобиля. 
    Он создается при создании автомобиля и полностью управляется автомобилем. 
    В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.
    
    Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, 
    и передается в конструктор автомобиля в качестве параметра.


SOLID
http://bb3x.ru/blog/shpargalka-po-solid-tezisam-s-primerami-na-php/
http://www.interface.ru/home.asp?artId=35612

S - Single-responsiblity principle
    принцип единой обязанности(ответственности).
    любой объект должен иметь только одну обязанность  и эта обязаность должна быть полностью
    реализована в классе объекта
O - Open-closed principle
    Принцип открытости закрытости.
    Классы должны быть открыты для расширения и закрыты для изменения
    https://netsh.pp.ua/2020/03/principy-solid-v-oop-ocp-chast-2-iz-5/
    
L - Liskov substitution principle. 
    Принцип подстановки Лисков.
    Поведение наследуемых классов не должно противоречить поведению заданному базовым классом.
    Объекты в программе могут быть заменены их наследниками без изменения свойств программы.
I - Interface segregation principle. 
    Принцип разделения интерфейса.
    Много специализированных интерфейсов лучше чем один универсальный.
D - Dependency Inversion Principle.
    Принцип инверсии зависимостей
    Зависимости должны строится относительно абстракций(интерфейсов) а не деталей(классов).


Принцип единственной ответственности (Single responsibility)
«На каждый объект должна быть возложена одна единственная обязанность»
Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.

Принцип открытости/закрытости (Open-closed)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации»
Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.

Принцип подстановки Барбары Лисков (Liskov substitution)
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы»
Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается

Принцип разделения интерфейса (Interface segregation)
«Много специализированных интерфейсов лучше, чем один универсальный»
Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.

Принцип инверсии зависимостей (Dependency Invertion)
«Зависимости должны строится относительно абстракций, а не деталей»
Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.
