полиморфизм
  один интерфейс - много реализаций
инкапсуляция
  отделение интерфейса от реализации
  Способность объекта скрывать свою реализацию
наследование
  Наследование это процесс благодаря которому один объект может приобрести свойства другого объекта 
  (наследование всех свойств одного объекта другим) и добавлять черты характерны только для него самого!



SOLID
S - Single-responsiblity principle
    принцип единой обязанности(ответственности).
    любой объект должен иметь только одну обязанность  и эта обязаность должна быть полностью
    реализована в классе объекта
O - Open-closed principle
    Принцип открытости закрытости.
    Классы должны быть открыты для расширения и закрыты для изменения
L - Liskov substitution principle. 
    Принцип подстановки Лисков.
    Поведение наследуемых классов не должно противоречить поведению заданному базовым классом.
    Объекты в программе могут быть заменены их наследниками без изменения свойств программы.
I - Interface segregation principle. 
    Принцип разделения интерфейса.
    Много специализированных интерфейсов лучше чем один универсальный.
D - Dependency Inversion Principle.
    Принцип инверсии зависимостей
    Зависимости должны строится на относительно Абстракций а не деталей(классов).


Принцип единственной ответственности (Single responsibility)
«На каждый объект должна быть возложена одна единственная обязанность»
Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.

Принцип открытости/закрытости (Open-closed)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации»
Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.

Принцип подстановки Барбары Лисков (Liskov substitution)
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы»
Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается

Принцип разделения интерфейса (Interface segregation)
«Много специализированных интерфейсов лучше, чем один универсальный»
Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.

Принцип инверсии зависимостей (Dependency Invertion)
«Зависимости должны строится относительно абстракций, а не деталей»
Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.
