33. Какие типы переменных есть в Ruby?
  Numbers
    Fixnum
    Bignum
    Float
    Complex
    Rational
    BigDecimal
  Strings
  Symbols
    immutable string. faster then string
  Hashes
  Arrays
  Booleans
34. Что вернётся в результате сложения 10.5 и 10?
 20.5
35. Чем отличаются переменные, начинающиеся с @, @@ и $?

36. Что такое attr_reader, attr_writer, attr_accessor и зачем они?
  attr_reader - getters
  attr_writer - setters
  attr_accessor - all access
37. Что такое метод?
  a function or procedure which belong to a class or object
38. Что значит "?" в конце названия методов? Что означает "!" в конце названия методов?
  ?
39. Чем отличается энумератор map от each?

40. Что такое модуль? Какие есть варианты подключения модулей в класс?
  ?
41. Что такое класс и зачем он нужен?

42. Что такое модуль и зачем его используют? Чем модуль отличается от класса?

43. Что такое константа?

44. Что такое блок? Что такое yield? Можно ли передавать блоки в методы? Каким образом?
  yield - выполняет блок кода переданного в функцию
    def my_method
      yield 3
      yield 2
    end
    def method
      yield
    end
    method {puts "System.out.println();"}
    my_method { |x| puts x * 3 }

45. Что такое proc?
  prc = Proc.new { |x| return x * x }
  puts prc.call(8)
46. Что такое lambda?
  lm = lambda { |x| return x * x }
  puts lm.call(5)
47. В чем разница между proc и lambda?
   лямбда может возвращать значения
48. Что такое eigenclass?
    Во-первых, синтаксис class << foo открывает foo singleton class (eigenclass). 
    Это позволяет вам специализировать поведение методов, вызываемых этим конкретным объектом.
          a = 'foo'
          class << a
            def inspect
              '"bar"'
            end
          end
          a.inspect   # => "bar"

          a = 'foo'   # new object, new singleton class
          a.inspect   # => "foo"
          Теперь, чтобы ответить на вопрос: class << self открывает класс self singleton, поэтому методы могут 
          быть переопределены для текущего объекта self (который внутри тела класса или модуля является самим классом или модулем).
          Обычно это используется для определения методов класса/модуля ( "статические" ):

          class String
            class << self
              def value_of obj
                obj.to_s
              end
            end
          end

          String.value_of 42   # => "42"
          Это также можно записать в виде сокращения:


          class String
            def self.value_of obj
              obj.to_s
            end
          end
          Или даже короче:

          def String.value_of obj
            obj.to_s
          end
          Внутри определения функции self относится к объекту, с которым вызывается функция. 
          В этом случае class << self открывает одноэлементный класс для этого объекта; одним из них является внедрение машины с бедным человеком:

          class StateMachineExample
            def process obj
              process_hook obj
            end

          private
            def process_state_1 obj
              # ...
              class << self
                alias process_hook process_state_2
              end
            end

            def process_state_2 obj
              # ...
              class << self
                alias process_hook process_state_1
              end
            end

            # Set up initial state
            alias process_hook process_state_1
          end
          
49. Какие виды условных операторов есть в Ruby? (if, unless, ternary, case)

50. Есть ли разница между операторами && и and?
    && выполняются оба
    and первый потом второй
51. Какие виды циклов есть в Ruby? (loop, while, until, for, each(), times(), upto())
